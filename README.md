# Shell Sort希爾排序 11224121黃靖雅 期末報告


## 一、演算法概述

希爾排序（Shell Sort）是一種改良版的插入排序。它的核心想法是：先用較大的間隔（gap）讓資料在「大範圍」上初步有序，再逐漸縮小間隔，使資料越來越接近完全排序。

插入排序在處理接近有序的資料時非常高效，但如果資料差距太大，就需要頻繁搬移元素，效率會下降。希爾排序透過「分組 + 多輪調整」的方式，讓資料在進入最後一步（gap = 1 的情況，相當於普通插入排序）之前，已經大致排列好，因此整體效率比單純插入排序更高。


## 二、演算法步驟
### 1. 初始化間隔（增量）

首先要決定一個初始間距 gap，常見的做法是取陣列長度的一半（gap = n // 2）。

這個間距的作用是將整個陣列劃分成多個子序列，例如 gap = 4 時，索引相差 4 的元素會被歸為同一組。

間距在之後的迴圈中會逐漸縮小，直到最後變為 1。


### 2. 分組與插入排序

- 外層迴圈（gap 控制）
只要 gap > 0，就持續進行排序，每一輪之後將 gap 減半。

- 中層迴圈（遍歷子序列）
從第 gap 個元素開始，逐一遍歷到陣列末尾。這樣可以確保每個元素都會進入它所屬的子序列。

- 內層迴圈（子序列內插入排序）
將當前元素暫存為 temp，然後與子序列中更前方的元素比較：

   1.如果發現前方元素比 temp 大，就把它往後移一個間隔。

   2.重複這個動作，直到找到合適的位置，把 temp 插入進去。

   3.這樣能保證在當前的 gap 下，每個子序列都保持有序。

### 3.縮小間隔

在完成一輪以當前 gap 為間距的排序後，演算法會將 gap 進一步縮小（最常見的策略是整除 2，例如：8 → 4 → 2 → 1）。

這樣做的意義是：

- 大範圍先整理：較大的間距能先處理「跨距較遠」的元素，使它們大致移到比較合理的位置。

- 逐步細化：隨著間距縮小，子序列越來越接近於原始整體陣列，排序的細節會被逐步補上。

- 效率提升：當 gap 縮到 1 時，其實就是一次標準的插入排序，但此時陣列已經幾乎有序，插入排序能非常快速地完成最後的調整。


換句話說，縮小間隔的過程就是「先粗略分類，再精細排序」，這是希爾排序能優於單純插入排序的關鍵所在。

### 4.終止條件

演算法持續縮小間隔，直到 gap 最終減小為 0，此時外層迴圈結束。

在這個時候：

- 所有元素已經經歷過由大到小的間距調整；

- 陣列已經完全有序；

- 演算法正式完成排序任務。


這種「逐步逼近」的方式，確保了排序過程既不會漏掉任何元素的比較，也能在最後階段以最少的操作完成整體排序。

## 三、舉例流程圖
![image](https://github.com/05ki19lj/Shell-Sort/blob/main/Shell%20Sort%E5%9C%96%E6%A1%88%E7%AF%84%E4%BE%8B.png)

## 四、演算法特性

### 屬性 說明

- 時間複雜度:平均情況約 O(n^1.3 ~ n^1.5)，最壞情況接近 O(n^2)，取決於 gap 序列設計

- 空間複雜度:O(1)，就地排序

- 穩定性:不穩定，等值元素相對順序可能改變

- 適用場景:中等規模資料排序，內存有限時表現不錯；不要求穩定性的應用

## 五、完整的程式碼
### 這邊寫出運算的過程，以及運算結果
#include <stdio.h>

// 輔助函式：印出陣列
void print_array(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// 希爾排序（帶過程輸出）
void shell_sort(int arr[], int n) {
    int gap, i, j, temp, step = 1;

    // 初始化 gap，逐步縮小
    for (gap = n / 2; gap > 0; gap /= 2) {
        printf("\n--- 當前 gap = %d ---\n", gap);

        // 遍歷子序列中的元素
        for (i = gap; i < n; i++) {
            temp = arr[i];
            j = i;

            // 在子序列中做插入排序
            while (j >= gap && arr[j - gap] > temp) {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            arr[j] = temp;

            // 顯示每次插入後的狀態
            printf("步驟 %d: ", step++);
            print_array(arr, n);
        }
    }
}

int main() {
    int arr[] = {9, 8, 3, 7, 5, 6, 4, 1, 2};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("原始陣列: ");
    print_array(arr, n);

    shell_sort(arr, n);

    printf("\n最終排序結果: ");
    print_array(arr, n);

    return 0;
}

## 六、程式碼測試結果
![image](https://github.com/05ki19lj/Shell-Sort/blob/main/Shell%20Sort%20T.png)
