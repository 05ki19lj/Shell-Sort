# Shell-Sort


## 一、演算法概述

希爾排序（Shell Sort）是一種改良版的插入排序。它的核心想法是：先用較大的間隔（gap）讓資料在「大範圍」上初步有序，再逐漸縮小間隔，使資料越來越接近完全排序。

插入排序在處理接近有序的資料時非常高效，但如果資料差距太大，就需要頻繁搬移元素，效率會下降。希爾排序透過「分組 + 多輪調整」的方式，讓資料在進入最後一步（gap = 1 的情況，相當於普通插入排序）之前，已經大致排列好，因此整體效率比單純插入排序更高。


## 二、演算法步驟

1. 初始化間隔（增量）

首先要決定一個初始間距 gap，常見的做法是取陣列長度的一半（gap = n // 2）。

這個間距的作用是將整個陣列劃分成多個子序列，例如 gap = 4 時，索引相差 4 的元素會被歸為同一組。

間距在之後的迴圈中會逐漸縮小，直到最後變為 1。


2. 分組與插入排序

外層迴圈（gap 控制）
只要 gap > 0，就持續進行排序，每一輪之後將 gap 減半。

中層迴圈（遍歷子序列）
從第 gap 個元素開始，逐一遍歷到陣列末尾。這樣可以確保每個元素都會進入它所屬的子序列。

內層迴圈（子序列內插入排序）
將當前元素暫存為 temp，然後與子序列中更前方的元素比較：

如果發現前方元素比 temp 大，就把它往後移一個間隔。

重複這個動作，直到找到合適的位置，把 temp 插入進去。

這樣能保證在當前的 gap 下，每個子序列都保持有序。

3.縮小間隔

在完成一輪以當前 gap 為間距的排序後，演算法會將 gap 進一步縮小（最常見的策略是整除 2，例如：8 → 4 → 2 → 1）。

這樣做的意義是：

大範圍先整理：較大的間距能先處理「跨距較遠」的元素，使它們大致移到比較合理的位置。

逐步細化：隨著間距縮小，子序列越來越接近於原始整體陣列，排序的細節會被逐步補上。

效率提升：當 gap 縮到 1 時，其實就是一次標準的插入排序，但此時陣列已經幾乎有序，插入排序能非常快速地完成最後的調整。


換句話說，縮小間隔的過程就是「先粗略分類，再精細排序」，這是希爾排序能優於單純插入排序的關鍵所在。

4.終止條件

演算法持續縮小間隔，直到 gap 最終減小為 0，此時外層迴圈結束。

在這個時候：

所有元素已經經歷過由大到小的間距調整；

陣列已經完全有序；

演算法正式完成排序任務。


這種「逐步逼近」的方式，確保了排序過程既不會漏掉任何元素的比較，也能在最後階段以最少的操作完成整體排序。

## 四、演算法特性

屬性 說明

時間複雜度 平均情況約 O(n^1.3 ~ n^1.5)，最壞情況接近 O(n^2)，取決於 gap 序列設計
空間複雜度 O(1)，就地排序
穩定性 不穩定，等值元素相對順序可能改變
適用場景 中等規模資料排序，內存有限時表現不錯；不要求穩定性的應用

# 程式碼

from typing import List

class Solution:
    def shell_sort(self, arr: List[int]) -> List[int]:
        """
        使用 Shell Sort（希尔排序）对列表 arr 进行排序，返回排序后的列表。
        """
        n = len(arr)
        gap = n // 2  # 初始间隔

        # 当 gap > 0 时，不断缩小间隔进行分组插入排序
        while gap > 0:
            # 对每个间隔内（gap 分组）的元素执行插入排序
            for i in range(gap, n):
                temp = arr[i]
                j = i
                # 将比 temp 大的元素在同一分组中后移一个 gap
                while j >= gap and arr[j - gap] > temp:
                    arr[j] = arr[j - gap]
                    j -= gap
                arr[j] = temp  # 插入正确的位置

            # 缩小间隔，继续下一轮分组排序
            gap //= 2

        return arr

    def sortArray(self, nums: List[int]) -> List[int]:
        """
        用于兼容题目结构：调用 shell_sort 完成排序。
        """
        return self.shell_sort(nums)

# 示例：测试排序功能
if __name__ == "__main__":
    solution = Solution()
    examples = [
        [5, 2, 3, 1],
        [5, 1, 1, 2, 0, 0],
        [9, 8, 3, 7, 5, 6, 4, 1, 2],
    ]

    for arr in examples:
        sorted_arr = solution.sortArray(arr.copy())
        print(f"原始: {arr} → 排序后: {sorted_arr}")
